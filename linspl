AUERR = makeLinsplCorr(curdat, cmd);
QUIT

#include <baselineDef.c>
#include <subregion.c>
#include <specInfo.c>
	
static int makeLinsplCorr(const char* curdat, const char* cmd)
{
	float z[1000];
	int zsize; //unknown at compile time. set after filling
	int i, ii, iii, iiii;
	int regionsum;
	int subregions;
	float offset; //needed for datatype preservation when pulling from bruker parameter 
	double blSWppm=0;
	double regionsizeppm, subregioncenterppm;
	char dummystr[PATH_MAX];
	float intleft, intright;
	int num_regions=80;
	int leftpoint, rightpoint;
	int minsize;
	FILE *fptr;
	FILE *intfile;
	SPI spcInf;
	BL *blHead = NULL;
	 
	int indexOf(double peakShift, SPI spi)
	{
		return spi.si*((spi.left - peakShift)/(spi.sw_p/spi.sf));
	}

	if (access(PROCPATH("1r"),F_OK)!=0)
	{
		Proc_err(0,"no processed data.");
		return(-1);
	}
	int origprocno=procno;
	//save copy of initial spectrum in PROCNO 40 
	WRP(40);

	// read integral regions from datset's intrng file and put integral limits into z array 
	fptr=fopen(PROCPATH("intrng"), "r");
	if(fptr==NULL)
	{
		Proc_err(DEF_ERR_OPT, "No integral result file :\n%s", PROCPATH("intrng"));
		return(-1);
	}

	//discard first 2 lines 
	for (iii = 0; iii < 2; iii++)
	{
		fgets(dummystr, sizeof(dummystr), fptr);
	}

	// read integral limits 
	i = 0;
	while (fgets(dummystr, sizeof(dummystr), fptr))
	{
		(void) sscanf(dummystr,"%f %f %*s %*s",&intleft, &intright);
		if (intleft > intright+0.00001)
		{
			z[i++]=intleft;
			z[i++]=intright;
		}
	}
	zsize=i;
	fclose(fptr);

	FETCHPARS("SI",&spcInf.si);
	minsize = spcInf.si/500;

	FETCHPARS("OFFSET",&spcInf.offset);
	FETCHPARS("SW_p",&spcInf.sw_p);
	FETCHPARS("SF",&spcInf.sf);
	spcInf.left = spcInf.offset;
	spcInf.right = spcInf.left - (spcInf.sw_p / spcInf.sf);
	
	// iter through blind regions storing the resulting offset start/stop ppm and index values in a linked list of type BL
	// store cummulative sum (ppm) of the entire baseline in blSWppm
	if(spcInf.left>z[0])
	{
		leftpoint=0;
		rightpoint = indexOf(z[0], spcInf);
		if ((rightpoint - leftpoint) > minsize)
		{
			insertatendofBL(&blHead, spcInf.left, z[0], leftpoint, rightpoint);
			blSWppm += spcInf.left-z[0];
		}
	}

	for(i=1; i < zsize-1; i+=2)
	{
		if (z[i]>z[i+1])
		{
			leftpoint = indexOf(z[i], spcInf);
			rightpoint = indexOf(z[i+1], spcInf);
			if ((rightpoint - leftpoint) > minsize)
			{
				insertatendofBL(&blHead, z[i], z[i+1], leftpoint, rightpoint);
				blSWppm += z[i]-z[i+1];
			}	
		}
	}
	if(z[zsize-1] > spcInf.right)
	{
		leftpoint = indexOf(z[zsize-1], spcInf);
		rightpoint = spcInf.si-1;
		if ((rightpoint - leftpoint) > minsize)
		{
			insertatendofBL(&blHead, z[zsize-1], spcInf.right, leftpoint, rightpoint);
			blSWppm += z[zsize-1] - spcInf.right;
		}
	}
	fprintBLs(blHead);
	// Divide the baseline into 80 roughly equal subregions and use extracted real data
	// save x, y (average), index information in a linked list of type SR
	regionsizeppm = blSWppm/num_regions;
	FILE *datafile;
	long  *pld; 
	long *ldata; // use this pointer to store reals
	int readin;
	int cant_modify_1r=0;
	if ( ( ldata = (long *)malloc(sizeof(long) * spcInf.si ) )==NULL )
	//if ( ( ldata = (long *)malloc(sizeof(long) * si ) )==NULL )
	{
		Proc_err(0,"Could not allocate memory for data?");
		cant_modify_1r=1;
	}
	
	if ( ( datafile = fopen(PROCPATH("1r"), "r+") ) == NULL)
	{
		Proc_err(INFO_OPT, "Could not open data file %s for read/write - ignored", PROCPATH("1r"));
		cant_modify_1r=1;
	}
	else if ( (readin = fread(ldata, sizeof(int), spcInf.si, datafile)) != spcInf.si)
	{
		Proc_err(INFO_OPT, "read only %d of %d points from %s - ignored", readin, spcInf.si, PROCPATH("1r"));
		fclose(datafile);
		cant_modify_1r=1;
	}

	BL *blIter = blHead;
	// make the first subregion using the average of the first 10 reals
  long ppmDiff = (spcInf.right - spcInf.left)/spcInf.si;
  int specIndex, specSum, specAve;
  for (specIndex = 0; specIndex<9; specIndex++)
  {
  	specSum += ldata[specIndex];
  }
  specAve = specSum/(specIndex + 1);
  SR *srHead = NULL;
  SR *tmpsrHead = (struct subregion*) malloc(sizeof(SR));
  tmpsrHead->srleftppm = spcInf.left;
  tmpsrHead->srrightppm = spcInf.left - ppmDiff;
  tmpsrHead->center = 0;
  tmpsrHead->average = specAve;
  tmpsrHead->regionsum = 0;
  tmpsrHead->next = NULL;
  srHead = tmpsrHead;

	//make the n-2 subregions
	while (blIter != NULL)
	{
		SRS srs;
		srs.subregions = 0.5 + ((blIter->startppm - blIter->endppm)/(regionsizeppm));  //regionsize = totalppm/num_regions
		if (srs.subregions == 0)
			srs.subregions=1;
	
		srs.subregionsize = (blIter->startppm - blIter->endppm)/srs.subregions;
		srs.subregionsizept = srs.subregionsize*spcInf.si/(spcInf.sw_p/spcInf.sf);
		// finally, loop through each subregion in current baseline region 
		for (ii=0; ii< srs.subregions; ii++)
		{
			insertatendofSR(&srHead, ii, blIter->startppm, srs, spcInf, ldata);
		}
		blIter = blIter->next;
	}
	// make the last subregion using the average of the last 10 reals
	specSum = 0;
	for (specIndex = spcInf.si -11; specIndex< spcInf.si - 1; specIndex++){
  	specSum += ldata[specIndex];
  }
  specAve = specSum/(10);  
  SR *srTail = srHead;
  SR *tmpsrTail = (struct subregion*) malloc(sizeof(SR));
  
  tmpsrTail->srleftppm = spcInf.right + ppmDiff;
  tmpsrTail->srrightppm = spcInf.right;
  tmpsrTail->center = spcInf.si - 1;
  tmpsrTail->average = specAve;
  tmpsrTail->regionsum = 0;
  tmpsrTail->next = NULL;  
  while(srTail->next != NULL)
  {
  	srTail = srTail->next;
  }
	srTail->next = tmpsrTail;
	fclose(datafile);	
	fprintSRs(srHead, spcInf);
	
	FILE* background;
	background = fopen(PROCPATH("background.txt"), "w");
	// now create spline points spectrum in PROCNO 43   
	SR *srIter = srHead;
	WRP(43)
	DATASET(name, expno, 43, disk, "")
	if ( ( datafile = fopen(PROCPATH("1r"), "r+") ) == NULL)
	{
		Proc_err(INFO_OPT, "Could not open data file %s for read/write - ignored", PROCPATH("1r"));
	}
	else if ( (readin = fread(ldata, sizeof(int), spcInf.si, datafile)) != spcInf.si)
	{
		Proc_err(INFO_OPT, "read only %d of %d points from %s - ignored", readin, spcInf.si, PROCPATH("1r"));
		fclose(datafile);
	} 
	else 
	{
		for (i=0; i<spcInf.si; i++)
		{
			ldata[i]=0;
		}
		while (srIter!=NULL)
		{
			//printf("srIter->center: %d\n", srIter->center);
			ldata[srIter->center] = srIter->average;
			srIter = srIter->next;
		}
		rewind(datafile);
		fwrite(ldata, sizeof(int), spcInf.si, datafile); 
		fclose(datafile);				
	}
	// now create linear ramp between spline points spectrum in PROCNO 42 
	srIter = srHead;
	WRP(42)
	int jj;
	DATASET(name, expno, 42, disk, "")
	if ( ( datafile = fopen(PROCPATH("1r"), "r+") ) == NULL)
	{
		Proc_err(INFO_OPT, "Could not open data file %s for read/write - ignored", PROCPATH("1r"));
	}
	else if ( (readin = fread(ldata, sizeof(int), spcInf.si, datafile)) != spcInf.si)
	{
		Proc_err(INFO_OPT, "read only %d of %d points from %s - ignored", readin, spcInf.si, PROCPATH("1r"));
		fclose(datafile);
	} 
	else 
	{
		//for (i=1; i<iiii; i++)
		//while (srIter->next!=NULL){
		while (srIter->next!=NULL)
		{
			jj = 0;
			for (ii=srIter->center; ii<srIter->next->center; ii++)	
			{
				// loop through points between pair of spline points and draw a straight line
				ldata[ii]=srIter->average + (ii-srIter->center)*(srIter->next->average - srIter->average)/(srIter->next->center - srIter->center);
				//fprintf(background, "ii - current center term: %d\n", ii-srIter->center);
			}
			srIter = srIter->next;
		}	
		rewind(datafile);
		fwrite(ldata, sizeof(int), spcInf.si, datafile);		
	}
	fclose(background);
	fclose(datafile);
	// procno41 = procno42 - procno43
  srIter = srHead;
	DATASET(name, expno, 41, disk, "")
	DATASET2(name, expno, 42, disk, "")
	DATASET3(name, expno, 43, disk, "")
	STOREPAR("DC",-1.0);
	ADD
	// create an integral file in here for each subregion 
	intfile=fopen(PROCPATH("intrng"), "w");

	if(intfile==NULL)
	{
		Proc_err(DEF_ERR_OPT, "Can't write integrals:\n%s", PROCPATH("intrng"));
		return(-1);
	}
	fprintf(intfile, "A 1.0 #regions in PPM\n");
	fprintf(intfile, "# low field   high field  bias        slope\n");
	//for (i=0; i<iiii; i++)
	while (srIter->next!=NULL)
	{
		fprintf(intfile,"%.3f   %.3f  0  0\n", srIter->srleftppm, srIter->srrightppm);
		srIter = srIter->next;
	}
	fclose(intfile);
	// procno1 = procno40 - procno42
	DATASET(name, expno, origprocno, disk, "")
	DATASET2(name, expno, 40, disk, "")
	DATASET3(name, expno, 42, disk, "")
	STOREPAR("DC",-1.0);
	ADD
	// Hilbert transform to update imaginary data 
	HT
	return 0;
}

 

